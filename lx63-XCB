-- Skidded By Xyra 
local Rayfield = loadstring(game:HttpGet('https://sirius.menu/rayfield'))()
local Window = Rayfield:CreateWindow({
	Name = "Xyra's Bypasser",
	Icon = 107909896307696, 
	LoadingTitle = "Xyra Bypasser v1.0 -- Femboy Edition",
	LoadingSubtitle = "Loading V1.1 Enjoy Slurring",
	ShowText = "Rayfield", 
  Theme = {
-- Primary Text Color (Kept mostly white for contrast on dark background)
    TextColor = Color3.fromRGB(240, 240, 240),

    -- REQUESTED TO KEEP
    Background = Color3.fromRGB(21, 10, 75), 
    
    -- Deep Blue for main structure (No change needed here)
    Topbar = Color3.fromRGB(30, 50, 90),          -- Dark Navy
    Shadow = Color3.fromRGB(10, 40, 75),         -- Dark Navy

    -- REQUESTED TO KEEP
    NotificationBackground = Color3.fromRGB(66, 58, 110),
    NotificationActionsBackground = Color3.fromRGB(66, 58, 110),

    -- Tabs (Slightly darker blue-gray)
    TabBackground = Color3.fromRGB(30, 50, 90),       -- Slightly darker than before
    TabStroke = Color3.fromRGB(40, 60, 105),           
    TabBackgroundSelected = Color3.fromRGB(20, 45, 85), -- PRIMARY BLUE for selected tab
    TabTextColor = Color3.fromRGB(240, 240, 240),      
    SelectedTabTextColor = Color3.fromRGB(240, 240, 240), 

    -- Element Backgrounds (Inputs, Buttons, etc.) -- ðŸ› ï¸ DARKENED ðŸ› ï¸
    ElementBackground = Color3.fromRGB(20, 45, 85),     -- Muted blue, slightly darker
    ElementBackgroundHover = Color3.fromRGB(30, 60, 110), -- Maintains clear hover contrast
    SecondaryElementBackground = Color3.fromRGB(10, 35, 70), -- Darker background for variety
    ElementStroke = Color3.fromRGB(45, 70, 115),       
    SecondaryElementStroke = Color3.fromRGB(35, 60, 100), 

    -- Slider (Using the vibrant PRIMARY BLUE and ACCENT SKY) 
    SliderBackground = Color3.fromRGB(20, 45, 85),    
    SliderProgress = Color3.fromRGB(0, 123, 255),      
    SliderStroke = Color3.fromRGB(128, 191, 255),      

    -- Toggles (Using blue for enabled, gray-blue for disabled) -- ðŸ› ï¸ DARKENED ðŸ› ï¸
    ToggleBackground = Color3.fromRGB(20, 45, 85),     -- Muted blue, slightly darker
    ToggleEnabled = Color3.fromRGB(0, 123, 255),       
    ToggleDisabled = Color3.fromRGB(5, 30, 65),        -- Darker Navy for disabled
    ToggleEnabledStroke = Color3.fromRGB(128, 191, 255), 
    ToggleDisabledStroke = Color3.fromRGB(45, 70, 115),  
    ToggleEnabledOuterStroke = Color3.fromRGB(45, 70, 115),
    ToggleDisabledOuterStroke = Color3.fromRGB(5, 30, 65),

    -- Dropdowns -- ðŸ› ï¸ DARKENED ðŸ› ï¸
    DropdownSelected = Color3.fromRGB(30, 60, 110),   -- Matches hover
    DropdownUnselected = Color3.fromRGB(20, 45, 85),   -- Matches Element Background

    -- Inputs -- ðŸ› ï¸ DARKENED ðŸ› ï¸
    InputBackground = Color3.fromRGB(10, 35, 70),     -- Dark Navy input background
    InputStroke = Color3.fromRGB(45, 70, 115),        
    PlaceholderColor = Color3.fromRGB(180, 200, 220)
    },-- End of the Theme table.

      ToggleUIKeybind = "K",
	

	DisableRayfieldPrompts = false,
	DisableBuildWarnings = false, 

	ConfigurationSaving = {
		Enabled = true,
		FolderName = xyrasbypasser,
		FileName = "Big Hub"
	},

	Discord = {
		Enabled = true, 
		Invite = "E7myjT34m7", 
		RememberJoins = true
	},

	KeySystem = true, 
	KeySettings = {
		Title = "Xyra Bypasser Key",
		Subtitle = "Key System",
		Note = "Join The Discord For Key :3", 
		FileName = "Key", 
		SaveKey = true, 
		GrabKeyFromSite = false, 
		Key = {"ILoveFemboys"} 
	}
})



-- Constant Method Options (AUTHORITATIVE LIST)
local METHOD_OPTIONS = {
	"Method 1 (tags the least)", 
	"Method 2 ", 
	"Method 3 ", 
	"Method 4 ", 
	"Method 5 ", 
	"Method 6 "
}

-- Global State Variables
local autobypass = false
-- 'method' now stores the numerical index (1-6)
local method = 1 
local logging = false
local webhook = ""
local spamMessage = ""
local spamInterval = 1
local spaming = false
local spamThread = nil
local apiKey = ""
local isChatbotEnabled = false
local botModel = "llama3-8b-8192"
local personality = "Default"
local blacklist = {}

-- UI Component Reference
local textBox = game:GetService("CoreGui").ExperienceChat.appLayout.chatInputBar.Background.Container.TextContainer.TextBoxContainer.TextBox

-- [ CORE UTILITY FUNCTIONS ]

local function chat(msg)
	if game:GetService("TextChatService").ChatVersion == Enum.ChatVersion.TextChatService then
		game:GetService("TextChatService").TextChannels.RBXGeneral:SendAsync(msg)
	else
		game.ReplicatedStorage.DefaultChatSystemChatEvents.SayMessageRequest:FireServer(msg, "All")
	end
end

local function sendToWebhook(msg, username)
	local data = {
		content = "**" .. username .. "**: " .. msg,
		username = "Chat Logger"
	}

	local requestData = {
		Url = webhook,
		Method = "POST",
		Headers = {
			["Content-Type"] = "application/json",
		},
		Body = game:GetService("HttpService"):JSONEncode(data)
	}

	pcall(function()
		request(requestData)
	end)
end

local function bypasstext(text, methodIndex)
	-- CRITICAL SAFETY CHECK: Ensure methodIndex is a number before comparison
	if type(methodIndex) ~= "number" then
		methodIndex = 1
	end
	-- This function accepts the numerical index directly (1-6)
	if methodIndex == 1 then
		local function addAccents(word)
local accents = {
    a = "à¸ª", b = "áƒ®", c = "Ï²", d = "d", e = "e", f = "Æ­", g = "g", h = "Ò»",
    i = "à¹€à¹ˆ", j = "j", k = "Ï—", l = "Æ–", m = "à¸¦à¹…", n = "à¸–", o = "Î¿", p = "p",
    q = "q", r = "êž…", s = "à¸˜", t = "t", u = "à¸¡", v = "v", w = "Ñ¡", x = "x",
    y = "â´˜", z = "z",

    A = "à¸ª", B = "áƒ®", C = "Ï²", D = "d", E = "e", F = "Æ­", G = "g", H = "Ò»",
    I = "à¹€à¹ˆ", J = "j", K = "Ï—", L = "Æ–", M = "à¸¦à¹…", N = "à¸–", O = "Î¿", P = "p",
    Q = "q", R = "êž…", S = "à¸˜", T = "t", U = "à¸¡", V = "v", W = "Ñ¡", X = "x",
    Y = "â´˜", Z = "z"
}
			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i)
				bypassedWord = bypassedWord .. (accents[letter] or letter)
			end
			return bypassedWord
		end

		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents(word))
			end
			return table.concat(words, " ")
		end
		return bypassString(text)
	elseif methodIndex == 2 then
		local function addAccents2(word)
			local accents2 = {
    a = "à¸ª",  b = "áƒ®",  c = "Í¼",  d = "áƒ«",  e = "É",  f = "Æ­",  g = "g", h = "É§",
    i = "à¹€à¹ˆ", j = "j",  k = "ÒŸ",  l = "Æ–",  m = "m",  n = "à¸–",  o = "à¸”",  p = "Ò×",
    q = "q",  r = "êž…",  s = "à¸˜",  t = "t",  u = "à¸¡",  v = "v",  w = "w×‚", x = "Ó½",
    y = "y",  z = "×‚z",

    A = "à¸„",  B = "áƒ®",  C = "Í¼",  D = "áƒ«",  E = "É",  F = "Æ­",  G = "É•×", H = "É§",
    I = "à¹€à¹ˆ", J = "j",  K = "ÒŸ",  L = "Æ–",  M = "m",  N = "à¸–",  O = "à¸”",  P = "Ò×",
    Q = "q",  R = "êž…",  S = "à¸˜",  T = "t",  U = "à¸¡",  V = "v",  W = "w×‚", X = "Ó½",
    Y = "y",  Z = "×‚z",
			}
			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i)
				bypassedWord = bypassedWord .. (accents2[letter] or letter)
			end
			return bypassedWord
		end
		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents2(word))
			end
			return table.concat(words, " ")
		end
		return bypassString(text)
	elseif methodIndex == 3 then
		local function addAccents3(word)
			-- à¸ª áƒ® Ï² d e Æ­ g êœ§××… à¹€à¹ˆ j Ï— Æ– m à¸– o p q êž… à¤½ t à¸¡ v Ñ¡ Ó½ â´˜ z
			local accents3 = {
    a="à¸ª", b="áƒ®", c="Ï²", d="d", e="e", f="Æ­", g="g", h="êœ§××…",
    i="à¹€à¹ˆ", j="j", k="Ï—", l="Æ–", m="m", n="à¸–", o="o", p="p",
    q="q", r="êž…", s="à¤½", t="t", u="à¸¡", v="v", w="Ñ¡", x="Ó½",
    y="â´˜", z="z",
    A="à¸ª", B="áƒ®", C="Ï²", D="d", E="e", F="Æ­", G="g", H="êœ§××…",
    I="à¹€à¹ˆ", J="j", K="Ï—", L="Æ–", M="m", N="à¸–", O="o", P="p",
    Q="q", R="êž…", S="à¤½", T="t", U="à¸¡", V="v", W="Ñ¡", X="Ó½",
    Y="â´˜", Z="z"


}
			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i)
				bypassedWord = bypassedWord .. (accents3[letter] or letter)
			end
			return bypassedWord
		end
		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents3(word))
			end
			return table.concat(words, " ")
		end
		return bypassString(text)
	elseif methodIndex == 4 then -- NOW uses Method 1's logic
		local function addAccents4(word)
			local accents4 = {
        -- à¸„ áƒ® c áƒ« É f g êš• à¹€à¹‹ áŸ— à¸« Æ– à¸¦à¹… à¸ à¹‘ Æ¿ q êž… à¸˜ t à¸© à¸© Æœ x Ñƒ z
    a="à¸„", b="áƒ®", c="c", d="áƒ«", e="É", f="f", g="g", h="êš•",
    i="à¹€à¹‹", j="áŸ—", k="à¸«", l="Æ–", m="à¸¦à¹…", n="à¸", o="à¹‘", p="Æ¿",
    q="q", r="êž…", s="à¸˜", t="t", u="à¸©", v="à¸©", w="Æœ", x="x",
    y="Ñƒ", z="z",
    A="à¸„", B="áƒ®", C="c", D="áƒ«", E="É", F="f", G="g", H="êš•",
    I="à¹€à¹‹", J="áŸ—", K="à¸«", L="Æ–", M="à¸¦à¹…", N="à¸", O="à¹‘", P="Æ¿",
    Q="q", R="êž…", S="à¸˜", T="t", U="à¸©", V="à¸©", W="Æœ", X="x",
    Y="Ñƒ", Z="z"


			}
			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i)
				bypassedWord = bypassedWord .. (accents4[letter] or letter)
			end
			return bypassedWord
		end
		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents4(word))
			end
			return table.concat(words, " ")
		end
		return bypassString(text)
	elseif methodIndex == 5 then -- NOW uses Method 1's logic
		local function addAccents5(word)
			local accents5 = {
-- Lowercase Mapping
-- Lowercase Mapping
   a = "à¸ª", b = "Æ€", c = "á²ƒ", d = "á¸“", e = "á¸—", f = "áµ®", g = "Ç¥", h = "Ä§",
    i = "Ä¯", j = "Ê", k = "ÒŸ", l = "È´", m = "É±", n = "Å†", o = "ÏŒ×", p = "áµ½",
    q = "ê—", r = "È‘", s = "Ê‚", t = "Ô", u = "Å«", v = "á¹¿", w = "Åµ", x = "áº",
    y = "É£", z = "Ê‘",

    -- uppercase (using same glyphs where uppercase variants aren't distinct)
    A = "à¸ª", B = "Æ€", C = "á²ƒ", D = "á¸“", E = "á¸—", F = "áµ®", G = "Ç¥", H = "Ä§",
    I = "Ä¯", J = "Ê", K = "ÒŸ", L = "È´", M = "É±", N = "Å†", O = "ÏŒ×", P = "áµ½",
    Q = "ê—", R = "È‘", S = "Ê‚", T = "Ô", U = "Å«", V = "á¹¿", W = "Åµ", X = "áº",
    Y = "É£", Z = "Ê‘",

			}
			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i)
				bypassedWord = bypassedWord .. (accents5[letter] or letter)
			end
			return bypassedWord
		end
		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents5(word))
			end
			return table.concat(words, " ")
		end  
		return bypassString(text)
	elseif methodIndex == 6 then
		local function addAccents6(word)
			local accents6 = {
    a="a", b="áƒ®", c="Ï²××…", d="áƒ«", e="É", f="Æ­××…", g="qÙŒ", h="Ô¦××…",
    i="à¹€à¹‹", j="áŸ—", k="Ò›××…", l="Æ–", m="à¸¦à¹…", n="à¸‘", o="à¸”", p="Ò×",
    q="q", r="êž…××…", s="áƒ½", t="à§", u="à¸¡", v="v", w="w", x="Ó½××…",
    y="á¦", z="z",
    A="a", B="áƒ®", C="Ï²××…", D="áƒ«", E="É", F="Æ­××…", G="qÙŒ", H="Ô¦××…",
    I="à¹€à¹‹", J="áŸ—", K="Ò›××…", L="Æ–", M="à¸¦à¹…", N="à¸‘", O="à¸”", P="Ò×",
    Q="q", R="êž…××…", S="áƒ½", T="à§", U="à¸¡", V="v", W="w", X="Ó½××…",
    Y="á¦", Z="z"
   
} 

			local bypassedWord = ""
			for i = 1, #word do
				local letter = word:sub(i, i):lower()
				bypassedWord = bypassedWord .. (accents6[letter] or letter)
			end
			return bypassedWord
		end
		local function bypassString(input)
			local words = {}
			for word in string.gmatch(input, "%S+") do
				table.insert(words, addAccents6(word))
			end
			return table.concat(words, " ")
		end
		return bypassString(text)
	end
end




local function isBlacklisted(name)
	for _, blacklisted in pairs(blacklist) do
		if name == blacklisted then
			return true
		end
	end
	return false
end

local function askChatbot(msg, plrname)
	-- Chatbot API logic not implemented. Returning placeholder response.
	warn("Chatbot API logic not implemented. Returning placeholder response.")
	return "Chatbot function is not fully implemented."
end

local function getServers()
	local request = request({
		Url = "https://games.roblox.com/v1/games/" .. game.PlaceId .. "/servers/Public?sortOrder=Desc&limit=100",
		Method = "GET",
	})

	if request.StatusCode == 200 then
		local serverData = game:GetService("HttpService"):JSONDecode(request.Body)
		local serverList = {}

		for _, server in pairs(serverData.data) do
			local serverInfo = {
				serverId = server.id or "N/A",
				players = server.playing or 0,
				maxPlayers = server.maxPlayers or 0,
				ping = server.ping or "N/A",
			}

			table.insert(serverList, serverInfo)
		end

		return serverList
	else
		return nil
	end
end

local function refreshServers(serversTab)
	-- Clear previous buttons
	for _, child in pairs(serversTab.ContentFrame:GetChildren()) do
		if child:IsA("Frame") and child.Name == "ButtonContainer" then	
			child:Destroy()
		end
	end

	local servers = getServers()
	if servers then
		for _, server in pairs(servers) do
			serversTab:CreateButton({
				Name = "Players: " .. server.players .. "/" .. server.maxPlayers .. "\nPing: " .. server.ping,
				Callback = function()
					game:GetService("TeleportService"):TeleportToPlaceInstance(game.PlaceId, server.serverId, game.Players.LocalPlayer)
				end
			})
		end
	end
end





-- [ CHAT BYPASS TAB ]
local chatTab = Window:CreateTab("Chat Bypass", 107909896307696)
local ProtectionTab = Window:CreateTab("Protection")

local Players = game:GetService("Players")
local plr = Players.LocalPlayer
local plrs = Players
-- The Character might not be loaded yet, so wait for it
local bozo = plr.Character or plr.CharacterAdded:Wait()
local hrp = bozo:WaitForChild("HumanoidRootPart", math.huge)

local rs = game:GetService("RunService")
local nif = Instance.new("Sound")
nif.Parent = game:GetService("SoundService")
nif.SoundId = "rbxassetid://9086208751"
nif.Volume = 1

-- Utility for notifications
local function Nifs(text)
    game:GetService("StarterGui"):SetCore("SendNotification",{
        ["Title"] = "(//Fedoratum Anti Fling//)",
        ["Text"] = text,
        ["Duration"] = 4
    })
    nif:Play()
end

-- UI Toggle Control Variables
local antiFlingEnabled = false 
local isRunning = false      -- Flag to manage the continuous loop for XPart update

-- Variables for Fling Logic
local char, chares, hume
local hrpo, hrpl
local Update = true -- Controls if XPart should follow HRP

-- Create the Anti Fling Part once
local XPart = Instance.new("Part", game.Workspace)
XPart.Position = hrp.Position + Vector3.new(0,2,0)
XPart.Anchored = true
XPart.CanCollide = false
XPart.Transparency = 1.5

-- Create the BillboardGui once
local GUI = Instance.new("BillboardGui", XPart)
GUI.Size = UDim2.new(4, 0, 2, 0)
GUI.StudsOffsetWorldSpace = Vector3.new(0,1.5,0)
local TextLabel = Instance.new("TextLabel", GUI)
TextLabel.Text = ""
TextLabel.Size = UDim2.new(1,0,1,0)
TextLabel.BackgroundTransparency = 1.5
TextLabel.Font = "AmaticSC"
TextLabel.TextScaled = true


-- 1. Fling Detection (RenderStepped)
-- This connection stays active but only runs its code if antiFlingEnabled is true.
rs.RenderStepped:Connect(function()
    if antiFlingEnabled then
        pcall(function()
            chares = plr.Character or plr.CharacterAdded:Wait()
            hrpo = chares.HumanoidRootPart
            hume = chares.Humanoid
            
            if chares and hrpo then
                -- Check for high velocity (Fling)
                if hrpo.Velocity.Magnitude > 100 then
                    hume:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                    hume:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                    
                    Update = false -- Stop XPart from following
                    
                    -- Reset physics properties and velocity for local character and nearby parts
                    for i,v in ipairs(chares:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                            v.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                            v.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                        end
                    end
                    for _, v in pairs(plrs:GetPlayers()) do
                        if v ~= plr then
                            local c = v.Character
                            if c and c.Parent then
                                for _, v1 in pairs(c:GetDescendants()) do
                                    if v1:IsA("BasePart") then
                                        v1.Velocity = Vector3.new(0,0,0)
                                        v1.RotVelocity = Vector3.new(0,0,0)
                                    end
                                end
                            end
                        end
                    end
                    
                    -- Reset HRP physics and teleport to the XPart's CFrame
                    hrpo.AssemblyAngularVelocity = Vector3.new(0, 0, 0)
                    hrpo.AssemblyLinearVelocity = Vector3.new(0, 0, 0)
                    hrpo.CustomPhysicalProperties = PhysicalProperties.new(0, 0, 0)
                    hrpo.CFrame = XPart.CFrame
                else
                    -- Normal state: Re-enable states and reset properties
                    hume:SetStateEnabled(Enum.HumanoidStateType.Ragdoll, false)
                    hume:SetStateEnabled(Enum.HumanoidStateType.FallingDown, false)
                    Update = true -- Allow XPart to follow again
                    hrpo.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5)
                    for i,v in ipairs(chares:GetDescendants()) do
                        if v:IsA("BasePart") then
                            v.CustomPhysicalProperties = PhysicalProperties.new(0.7, 0.3, 0.5)
                        end
                    end
                end
            end
        end)
    end
end)


-- 2. Update Part Logic (Controlled by a spawn loop)
local function runUpdatePartLogic()
    -- Loop runs continuously as long as the toggle is ON
    while antiFlingEnabled do
        pcall(function()
            char = plr.Character or plr.CharacterAdded:Wait()
            hrpl = char.HumanoidRootPart
            -- Only update XPart position if it's safe (Update == true)
            if Update then
                XPart.Position = hrpl.Position + Vector3.new(0,2,0)
                XPart.CFrame = CFrame.lookAt(XPart.Position, XPart.Position + hrpl.CFrame.LookVector)
            end
        end)
        task.wait(0.3)
    end
    isRunning = false -- Reset flag when the loop exits
end


-- 3. The UI Toggle (Rayfield)
ProtectionTab:CreateToggle({
    Name = "Anti Fling", 
    CurrentValue = false,
    Callback = function(val)
        antiFlingEnabled = val 
        
        if val == true then
            
            
            -- Start the UpdatePart loop in a new thread if it's not already running
            if not isRunning then
                isRunning = true
                task.spawn(runUpdatePartLogic)
            end
        else
            
            
            -- The 'while antiFlingEnabled' check in the loop handles turning it off
        end
    end
})

-- Initial notification that the feature is ready

Rayfield:Notify({Title = "XAF", Content = "XAF had loaded, Enjoy.", Image = 107909896307696, Duration = 3})














local Description = chatTab:CreateParagraph({Title = "WARNING", Content = "Change roblox language to shqipe for best experience"})

local Dropdown = chatTab:CreateDropdown({
	Name = "Method",	
	Options = METHOD_OPTIONS, -- Use the authoritative list
	CurrentOption = METHOD_OPTIONS[method], -- Use the string from the authoritative list
	Callback = function(val)
		local new_method = nil
		local val_str

		-- Handle Rayfield returning a table of options or a string
		if type(val) == "table" then
			val_str = tostring(val[1] or "")
		else
			val_str = tostring(val or "")
		end

		-- Extract the method number from the option text
		local method_num_str = val_str:match("Method (%d+)")
		if method_num_str then
			new_method = tonumber(method_num_str)
		end
		
		-- Validation and Fail-Safe
		if new_method and new_method >= 1 and new_method <= #METHOD_OPTIONS then
			method = new_method
			Rayfield:Notify({Title = "Method Set", Content = "Bypass set to: " .. METHOD_OPTIONS[method], Image = 107909896307696, Duration = 2})
		else
			-- FINAL FAIL-SAFE: Default to Method 1
			method = 1	
			warn("Rayfield Dropdown Input FAILED. Type:", type(val), "Value:", val_str)
			Rayfield:Notify({Title = "Error", Content = "Selection failed! Final default to Method 1.", Image = 107909896307696, Duration = 3})
		end
	end
})

chatTab:CreateInput({Name = "Chat", CurrentValue = "", PlaceholderText = "Enter Chat", RemoveTextAfterFocusLost = true, Callback = function(val)
	if val ~= "" then
		-- Use the guaranteed numerical 'method' variable directly
		chat(bypasstext(val, method))
	else
		Rayfield:Notify({Title = "Ops.", Content = "Looks like you didn't enter any text!", Image = 107909896307696, Duration = 5})
	end
end})

chatTab:CreateToggle({
	Name = "Auto Bypass",	
	CurrentValue = false,
	Callback = function(val)
		autobypass = val	
		if val == true then
			Rayfield:Notify({Title = "Auto Bypass", Content = "Auto bypass has been enabled!", Image = 107909896307696, Duration = 5})
		else
			Rayfield:Notify({Title = "Auto Bypass", Content = "Auto bypass has been disabled!", Image = 107909896307696, Duration = 5})
		end
	end
})

-- Auto Bypass Logic Connection	
-- Auto Bypass Logic Connection (updated to avoid duplicate messages)
local lastOriginalSent = nil
local lastOriginalTime = 0

textBox.FocusLost:Connect(function(enter)
	if enter and autobypass then
		if textBox.Text ~= "" then
			local original = textBox.Text
			-- generate bypassed message using the chosen numeric 'method'
			local bypassed = bypasstext(original, method)

			-- store original + timestamp so we can suppress it when it arrives
			lastOriginalSent = original
			lastOriginalTime = tick()

			-- clear the textbox immediately (reduces chance of local duplication)
			textBox.Text = ""

			-- send the bypassed message
			chat(bypassed)
		end
	end
end)
-- [ OTHER (LOG/SPAM) ]


-- Logging UI

local Description = chatTab:CreateParagraph({Title = "Spam Function", Content = "Whatever you type in the input box below will be spammed (doesn't get bypassed)"})
-- Chat Spam UI
chatTab:CreateInput({Name = "Message", CurrentValue = "", PlaceholderText = "Enter Message", RemoveTextAfterFocusLost = false, Callback = function(val)
	spamMessage = val
	end})

chatTab:CreateSlider({Name = "Interval", Range = {0, 10}, CurrentValue = 1, Suffix = "seconds", Callback = function(val)
	spamInterval = math.max(0.1, val)	
	end})

chatTab:CreateToggle({
	Name = "Spam",
	CurrentValue = false,
	Callback = function(val)
		if spamMessage == "" then
			Rayfield:Notify({Title = "Ops.", Content = "Looks like you didn't enter any text!", Image = 107909896307696, Duration = 5})
			spaming = false
			return	
		end
		
		spaming = val

		if spaming then
			spamThread = coroutine.wrap(function()	
				while spaming do
					chat(spamMessage)
					wait(spamInterval)
				end
			end)()
			Rayfield:Notify({Title = "Spam Enabled", Content = "Spamming message: " .. spamMessage, Image = 107909896307696, Duration = 5})
		else
			Rayfield:Notify({Title = "Spam Disabled", Content = "Stopped chat spam.", Image = 107909896307696, Duration = 5})
		end
	end
})

-- Utility Button
chatTab:CreateButton({
	Name = "Fix Filter",
	Callback = function()
		chat("abcdefg()!") -- does this even actually do shit? :skull: 
	end
})



--[[
Premades
Either stolen from usercreated or catbypasser, code written by xyra
]]

-- RACIST PREMADES
local Tab = Window:CreateTab("Racist")
local Paragraph = Tab:CreateParagraph({Title = "African Slurs", Content = "Slurs/Sterotypes for Africans"})
local Button = Tab:CreateButton({
   Name = "nigger",
   Callback = function(Racist1)
   Racist1 = chat("à¸–à¹€à¹ˆggeêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "stfu black barbie",
   Callback = function(Racist2)
   Racist2 = chat("à¸˜tÆ­à¸¡ áƒ®Æ–à¸ªÏ²Ï— áƒ®à¸ªêž…áƒ®à¹€à¹ˆe")
   end,
})
local Button = Tab:CreateButton({
   Name = "niggers are bad as fuck",
   Callback = function(Racist3)
   Racist3 = chat("à¸–à¹€à¹ˆggeêž…à¸˜ à¸ªêž…e áƒ®à¸ªd à¸ªà¸˜ Æ­à¸¡Ï²Ï—")
   end,
})
local Button = Tab:CreateButton({
   Name = "fried chicken munchin nigger",
   Callback = function(Racist4)
   Racist4 = chat("Æ­êž…à¹€à¹ˆed Ï²Ò»à¹€à¹ˆÏ²Ï—eà¸– à¸¦à¹…à¸¡à¸–Ï²Ò»à¹€à¹ˆà¸– à¸–à¹€à¹ˆggeêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "Proceed to project: Rape all niggers",
   Callback = function(Racist5)
   Racist5 = chat("pêž…Î¿Ï²eed tÎ¿ pêž…Î¿jeÏ²t: êž…à¸ªpe à¸ªÆ–Æ– à¸–à¹€à¹ˆggeêž…à¸˜")
   end,
})
local Button = Tab:CreateButton({
   Name = "Fuck black people",
   Callback = function(Racist6)
   Racist6 = chat("Æ­à¸¡Ï²Ï— áƒ®Æ–à¸ªÏ²Ï— peÎ¿pÆ–e")
   end,
})
local Button = Tab:CreateButton({
   Name = "niggers are just black monkeys",
   Callback = function(Racist7)
   Racist7 = chat("à¸–à¹€à¹ˆggeêž…à¸˜ à¸ªêž…e jà¸¡à¸˜t áƒ®Æ–à¸ªÏ²Ï— à¸¦à¹…Î¿à¸–Ï—eâ´˜à¸˜")
   end,
})
local Button = Tab:CreateButton({
   Name = "This shit is fucking ridiculous, nigger.",
   Callback = function(Racist8)
   Racist8 = chat("This shit is fucking ridiculous, nigger")
   end,
})

local Paragraph = Tab:CreateParagraph({Title = "Asian Slurs", Content = "Slurs/Sterotypes for Asians"})
local Button = Tab:CreateButton({
   Name = "shut the fuck up chink",
   Callback = function(Racist9)
   Racist9 = chat("à¸˜Ò»à¸¡t tÒ»e Æ­à¸¡Ï²Ï— à¸¡p Ï²Ò»à¹€à¹ˆà¸–Ï—")
   end,
})
local Button = Tab:CreateButton({
   Name = "Small eyed rice munchin zipperhead",
   Callback = function(Racist10)
   Racist10 = chat("à¸˜à¸¦à¹…à¸ªÆ–Æ– eâ´˜ed êž…à¹€à¹ˆÏ²e à¸¦à¹…à¸¡à¸–Ï²Ò»à¹€à¹ˆà¸– zà¹€à¹ˆppeêž…Ò»eà¸ªd")
   end,
})
local Button = Tab:CreateButton({
   Name = "Go munch kimchi soyback",
   Callback = function(Racist11)
   Racist11 = chat("gÎ¿ à¸¦à¹…à¸¡à¸–Ï²Ò» Ï—à¹€à¹ˆà¸¦à¹…Ï²Ò»à¹€à¹ˆ à¸˜Î¿â´˜áƒ®à¸ªÏ²Ï— ")
   end,
   
})
local Button = Tab:CreateButton({
   Name = "Shut the fuck up Yigger",
   Callback = function(Racist12)
   Racist12 = chat("à¸˜Ò»à¸¡t tÒ»e Æ­à¸¡Ï²Ï— à¸¡p â´˜à¹€à¹ˆggeêž… ")
   end,
   
})
local Button = Tab:CreateButton({
   Name = "kill yourself Slantey-eye'd yigger",
   Callback = function(Racist13)
   Racist13 = chat("Ï—à¹€à¹ˆÆ–Æ– â´˜Î¿à¸¡êž…à¸˜eÆ–Æ­ à¸˜Æ–à¸ªà¸–teâ´˜ eâ´˜e'd â´˜à¹€à¹ˆggeêž…")
   end,
   
})
local Button = Tab:CreateButton({
   Name = "you are a fucking yellow Seaweed-Sucker ",
   Callback = function(Racist14)
   Racist14 = chat("â´˜Î¿à¸¡ à¸ªêž…e à¸ª Æ­à¸¡Ï²Ï—à¹€à¹ˆà¸–g â´˜eÆ–Æ–Î¿Ñ¡ à¸˜eà¸ªÑ¡eed-à¸˜à¸¡Ï²Ï—eêž…")
   end,
   
})
local Button = Tab:CreateButton({
   Name = "Go fuck yourself Bandwidth Nigger",
   Callback = function(Racist15)
   Racist15 = chat("gÎ¿ Æ­à¸¡Ï²Ï— â´˜Î¿à¸¡êž…à¸˜eÆ–Æ­ áƒ®à¸ªà¸–dÑ¡à¹€à¹ˆdtÒ» à¸–à¹€à¹ˆggeêž…")
   end,
   
})
local Paragraph = Tab:CreateParagraph({Title = "Middle Eastern Slurs", Content = "Slurs/Sterotypes for Middle Eastern People"})
local Button = Tab:CreateButton({
   Name = "shut the fuck up slushy slinger",
   Callback = function(Racist16)
   Racist16 = chat("à¸˜Ò»à¸¡t tÒ»e Æ­à¸¡Ï²Ï— à¸¡p à¸˜Æ–à¸¡à¸˜Ò»â´˜ à¸˜Æ–à¹€à¹ˆà¸–geêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "Roach-Rancher Sand Nigger",
   Callback = function(Racist17)
   Racist17 = chat("êž…Î¿à¸ªÏ²Ò»-êž…à¸ªà¸–Ï²Ò»eêž… à¸˜à¸ªà¸–d à¸–à¹€à¹ˆggeêž… ")
   end,
})
local Button = Tab:CreateButton({
   Name = "Kill yourself osama bin faggen",
   Callback = function(Racist18)
   Racist18 = chat("Ï—à¹€à¹ˆÆ–Æ– â´˜Î¿à¸¡êž…à¸˜eÆ–Æ­ Î¿à¸˜à¸ªà¸¦à¹…à¸ª áƒ®à¹€à¹ˆà¸– Æ­à¸ªggeà¸–")
   end,
})
local Button = Tab:CreateButton({
   Name = "Go bomb a building or something you fucking camel fucker",
   Callback = function(Racist19)
   Racist19 = chat("gÎ¿ áƒ®Î¿à¸¦à¹…áƒ® à¸ª áƒ®à¸¡à¹€à¹ˆÆ–dà¹€à¹ˆà¸–g Î¿êž… à¸˜Î¿à¸¦à¹…etÒ»à¹€à¹ˆà¸–g â´˜Î¿à¸¡ Æ­à¸¡Ï²Ï—à¹€à¹ˆà¸–g Ï²à¸ªà¸¦à¹…eÆ– Æ­à¸¡Ï²Ï—eêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "The fuck did you just say dune nigger?",
   Callback = function(Racist20)
   Racist20 = chat("tÒ»e Æ­à¸¡Ï²Ï— dà¹€à¹ˆd â´˜Î¿à¸¡ jà¸¡à¸˜t à¸˜à¸ªâ´˜ dà¸¡à¸–e à¸–à¹€à¹ˆggeêž…?")
   end,
})
local Button = Tab:CreateButton({
   Name = "fuck you aladdin",
   Callback = function(Racist21)
   Racist21 = chat("Æ­à¸¡Ï²Ï— â´˜Î¿à¸¡ à¸ªÆ–à¸ªddà¹€à¹ˆà¸–")
   end,
})
local Button = Tab:CreateButton({
   Name = "get fucked demi-nigger",
   Callback = function(Racist22)
   Racist22 = chat("get Æ­à¸¡Ï²Ï—ed deà¸¦à¹…à¹€à¹ˆ-à¸–à¹€à¹ˆggeêž…")
   end,
})
local Paragraph = Tab:CreateParagraph({Title = "Hispanic Slurs", Content = "Slurs/Sterotypes for Native Americans"})
local Button = Tab:CreateButton({
   Name = "We don't want you here you dirty stupid Mexican taco muncher",
   Callback = function(Racist23)
   Racist23 = chat("Ñ¡e dÎ¿à¸–'t Ñ¡à¸ªà¸–t â´˜Î¿à¸¡ Ò»eêž…e â´˜Î¿à¸¡ dà¹€à¹ˆêž…tâ´˜ à¸˜tà¸¡pà¹€à¹ˆd à¸¦à¹…exà¹€à¹ˆÏ²à¸ªà¸– tà¸ªÏ²Î¿ à¸¦à¹…à¸¡à¸–Ï²Ò»eêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "go back to mexico beaner",
   Callback = function(Racist24)
   Racist24 = chat("gÎ¿ áƒ®à¸ªÏ²Ï— tÎ¿ à¸¦à¹…exà¹€à¹ˆÏ²Î¿ áƒ®eà¸ªà¸–eêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "Why are you talking to me taco muncher",
   Callback = function(Racist25)
   Racist25 = chat("Ñ¡Ò»â´˜ à¸ªêž…e â´˜Î¿à¸¡ tà¸ªÆ–Ï—à¹€à¹ˆà¸–g tÎ¿ à¸¦à¹…e tà¸ªÏ²Î¿ à¸¦à¹…à¸¡à¸–Ï²Ò»eêž…")
   end,
})
local Button = Tab:CreateButton({
   Name = "Shut the fuck up you dirty border nigger",
   Callback = function(Racist26)
   Racist26 = chat("à¸˜Ò»à¸¡t tÒ»e Æ­à¸¡Ï²Ï— à¸¡p â´˜Î¿à¸¡ dà¹€à¹ˆêž…tâ´˜ áƒ®Î¿êž…deêž… à¸–à¹€à¹ˆggeêž…")
   end,
})








-- HOMOPHOBIC TAB
local Tab = Window:CreateTab("Lgbtq")

local Paragraph = Tab:CreateParagraph({Title = "Gay Slurs", Content = "Slurs/Sterotypes for Gay Men"})

local Button = Tab:CreateButton({
   Name = "fuck the fag-parade, burn them all",
   Callback = function(Homophobe1)
   Homophobe1 = chat("Æ­à¸¡Ï²Ï— tÒ»e Æ­à¸ªg-pà¸ªêž…à¸ªde, áƒ®à¸¡êž…à¸– tÒ»eà¸¦à¹… à¸ªÆ–Æ–")
   end,
})
local Button = Tab:CreateButton({
   Name = "hard coded fag move: rage quit",
   Callback = function(Homophobe2)
   Homophobe2 = chat("Ò»à¸ªêž…d Ï²Î¿ded Æ­à¸ªg à¸¦à¹…Î¿ve: êž…à¸ªge qà¸¡à¹€à¹ˆt")
   end,
})
local Button = Tab:CreateButton({
   Name = "why the fuck are you still speaking faggot",
   Callback = function(Homophobe3)
   Homophobe3 = chat("Ñ¡Ò»â´˜ tÒ»e Æ­à¸¡Ï²Ï— à¸ªêž…e â´˜Î¿à¸¡ à¸˜tà¹€à¹ˆÆ–Æ– à¸˜peà¸ªÏ—à¹€à¹ˆà¸–g Æ­à¸ªggÎ¿t")
   end,
})
local Button = Tab:CreateButton({
   Name = "yeah yeah, imma call xyra to come fuck your gay ass",
   Callback = function(Homophobe4)
   Homophobe4 = chat("â´˜eà¸ªÒ» â´˜eà¸ªÒ», à¹€à¹ˆà¸¦à¹…à¸¦à¹…à¸ª Ï²à¸ªÆ–Æ– xâ´˜êž…à¸ª tÎ¿ Ï²Î¿à¸¦à¹…e Æ­à¸¡Ï²Ï— â´˜Î¿à¸¡êž… gà¸ªâ´˜ à¸ªà¸˜à¸˜")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophobe5)
   Homophobe5 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "Being lgbtq means you have autisim",
   Callback = function(Homophobe6)
   Homophobe6 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "shut the fuck up faggot",
   Callback = function(Homophobe7)
   Homophobe7 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "Shut your faggot mouth for a real nigga rape you",
   Callback = function(Homophobe8)
   Homophobe8 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "Abc to murder a black fag!",
   Callback = function(Homophobe9)
   Homophobe9 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "Gay ass nigga you masturbate to furry porn shut up",
   Callback = function(Homophobe10)
   Homophobe10 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Paragraph = Tab:CreateParagraph({Title = "Nonbinary Slurs", Content = "Slurs/Sterotypes for Nonbinary People"})


local Button = Tab:CreateButton({
   Name = "what the fuck is a they them",
   Callback = function(Homophob11)
   Homophob11 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "fuck you mean you have no gender? i'll check drop them draws",
   Callback = function(Homophobe12)
   Homophobe12 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "i identify as a registered sex offender",
   Callback = function(Homophobe13)
   Homophobe13 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophobe14)
   Homophobe14 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophobe15)
   Homophobe15 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophobe16)
   Homophobe16 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophobe17)
   Homophobe17 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Button = Tab:CreateButton({
   Name = "yall Faggots if you aint in discord.gg/E7myjT34m7",
   Callback = function(Homophob18)
   Homophobe18 = chat("â´˜à¸ªÆ–Æ– Æ­à¸ªggÎ¿tà¸˜ à¹€à¹ˆÆ­ â´˜Î¿à¸¡ à¸ªà¹€à¹ˆà¸–t à¹€à¹ˆà¸– dà¹€à¹ˆà¸˜Ï²Î¿êž…d.gg/e7à¸¦à¹…â´˜jt34à¸¦à¹…7")
   end,
})
local Paragraph = Tab:CreateParagraph({Title = "Furrys Slurs", Content = "Slurs/Sterotypes for Furrys"})

local Button = Tab:CreateButton({
   Name = "Ew nigga are you a fucking furry?",
   Callback = function(Furry1)
   Furry1 = chat("eÑ¡ à¸–à¹€à¹ˆggà¸ª à¸ªêž…e â´˜Î¿à¸¡ à¸ª Æ­à¸¡Ï²Ï—à¹€à¹ˆà¸–g Æ­à¸¡êž…êž…â´˜? ")
   end,
})
local Button = Tab:CreateButton({
   Name = "EWW faggot ass nigga in a fursuit",
   Callback = function(Furry2)
   Furry2 = chat("eÑ¡Ñ¡ Æ­à¸ªggÎ¿t à¸ªà¸˜à¸˜ à¸–à¹€à¹ˆggà¸ª à¹€à¹ˆà¸– à¸ª Æ­à¸¡êž…à¸˜à¸¡à¹€à¹ˆt")
   end,
})
local Button = Tab:CreateButton({
   Name = "Nigga you dress up as a dog for attention don't talk to me",
   Callback = function(Furry3)
   Furry3 = chat("à¸–à¹€à¹ˆggà¸ª â´˜Î¿à¸¡ dêž…eà¸˜à¸˜ à¸¡p à¸ªà¸˜ à¸ª dÎ¿g Æ­Î¿êž… à¸ªtteà¸–tà¹€à¹ˆÎ¿à¸– dÎ¿à¸–'t tà¸ªÆ–Ï— tÎ¿ à¸¦à¹…e ")
   end,
})



-- SEXUAL TAB
local Tab = Window:CreateTab("Sexual")
local Button = Tab:CreateButton({
   Name = "do i need to dick you down?",
   Callback = function(Sexual1)
   Sexual1 = chat("dÎ¿ à¹€à¹ˆ à¸–eed tÎ¿ dà¹€à¹ˆÏ²Ï— â´˜Î¿à¸¡ dÎ¿Ñ¡à¸–?")
   end,
})
local Button = Tab:CreateButton({
   Name = "shut the fuck up before a real nigga put it in you",
   Callback = function(Sexual2)
   Sexual2 = chat("à¸˜Ò»à¸¡t tÒ»e Æ­à¸¡Ï²Ï— à¸¡p áƒ®eÆ­Î¿êž…e à¸ª êž…eà¸ªÆ– à¸–à¹€à¹ˆggà¸ª pà¸¡t à¹€à¹ˆt à¹€à¹ˆà¸– â´˜Î¿à¸¡")
   end,
})
local Button = Tab:CreateButton({
   Name = "dont make me force my massive white cock in you",
   Callback = function(Sexual3)
   Sexual3 = chat("dÎ¿à¸–t à¸¦à¹…à¸ªÏ—e à¸¦à¹…e Æ­Î¿êž…Ï²e à¸¦à¹…â´˜ à¸¦à¹…à¸ªà¸˜à¸˜à¹€à¹ˆve Ñ¡Ò»à¹€à¹ˆte Ï²Î¿Ï²Ï— à¹€à¹ˆà¸– â´˜Î¿à¸¡")
   end,
})


local ScriptsTab = Window:CreateTab("More Scripts")

local Players = game:GetService("Players")
local LocalPlayer = Players.LocalPlayer
-- The character may not exist yet when the LocalScript starts, so wait for it
local Character = LocalPlayer.Character or LocalPlayer.CharacterAdded:Wait() 
local hrp = Character:WaitForChild("HumanoidRootPart")

local antiBang = false -- This variable controls the loop
local isRunning = false -- This flag prevents starting the loop multiple times

-- Function to handle the anti bang logic loop
local function runAntiBangLogic()
    -- Only run as long as the toggle is ON and the player/HRP exists
    while antiBang and hrp and hrp.Parent do 
        
        -- Store the current safe position
        local lastCFrame = hrp.CFrame
        
        -- Apply the temporary teleport to bypass the barrier
        workspace.FallenPartsDestroyHeight = -1000
        hrp.CFrame = CFrame.new(Vector3.new(0, -500, 0))
        
        task.wait(0.7)
        
        -- Return to the original position and reset the barrier height
        hrp.CFrame = lastCFrame
        workspace.FallenPartsDestroyHeight = -500
        
        -- Wait for a short duration before attempting the loop again
        task.wait(1) 
    end
    isRunning = false -- Reset the flag when the loop naturally exits (i.e., when antiBang is set to false)
end

ProtectionTab:CreateToggle({
    Name = "Anti Bang", 
    CurrentValue = false,
    Callback = function(val)
        -- Update the control variable
        antiBang = val 
        
        if val == true then
            Rayfield:Notify({Title = "Anti Bang", Content = "Anti bang has been enabled!", Duration = 5})
            
            -- If the loop is not already running, start it in a new thread
            if not isRunning then
                isRunning = true
                task.spawn(runAntiBangLogic)
            end
        else
            Rayfield:Notify({Title = "Anti Bang", Content = "Anti bang has been disabled!", Duration = 5})
            -- The 'while antiBang' check inside the function handles the turning OFF automatically.
        end
    end
})


local Paragraph = ScriptsTab:CreateParagraph({Title = "Admin Scripts", Content = " "})

local Button = ScriptsTab:CreateButton({
   Name = "Xyra's Admin",
   Callback = function(NamelessAdmin)
   NamelessAdmin = loadstring(game:HttpGet("https://xyra.lovable.app/XyraAdmin.lua"))()
   end,
})

local Button = ScriptsTab:CreateButton({
   Name = "Infinite Yield",
   Callback = function(InfiniteYield)
   InfiniteYield = loadstring(game:HttpGet('https://raw.githubusercontent.com/DarkNetworks/Infinite-Yield/main/latest.lua'))()
   end,
})
local Paragraph = ScriptsTab:CreateParagraph({Title = "Animation Scripts", Content = " "})
local Button = ScriptsTab:CreateButton({
   Name = "R6 Animation Gui",
   Callback = function(R6Animations)
   R6Animations = loadstring(game:HttpGet('https://raw.githubusercontent.com/RENBex6969/AnimationScripts/refs/heads/main/FE_R6_Animations_Gui.lua'))()
   end,
})



local Button = ScriptsTab:CreateButton({
   Name = "R15 Animation Gui",
   Callback = function(R15Animations)
   R15Animations = loadstring(game:HttpGet('https://raw.githubusercontent.com/RENBex6969/AnimationScripts/refs/heads/main/FE_R15_Animation_Gui_by_illremember.lua'))()
   end,
})

local Button = ScriptsTab:CreateButton({
   Name = "R15 Twerk",
   Callback = function(Twork)
   Twork = loadstring(game:HttpGet("https://pastebin.com/raw/46yzqpCs"))()
   end,
})

local Paragraph = ScriptsTab:CreateParagraph({Title = "Backdoor Scanners", Content = "If you are in a backdoored game this will give you a serverside executor"})

local Button = ScriptsTab:CreateButton({
   Name = "Lalol Hub",
   Callback = function(Twork)
   Twork = loadstring(game:HttpGet('https://raw.githubusercontent.com/Its-LALOL/LALOL-Hub/main/Backdoor-Scanner/script'))()
   end,
})
local Button = ScriptsTab:CreateButton({
   Name = "BeckDeer Skenner",
   Callback = function(Twork)
   Twork = loadstring(game:HttpGetAsync("https://raw.githubusercontent.com/jLn0n/beckdeer-skenner/main/src/main.lua"))()
   end,
})









local othersTab = Window:CreateTab("Settings")

othersTab:CreateButton({
	Name = "Destroy UI",
	Callback = function()
		Rayfield:Destroy()
	end
})

-- Xyra's ACL (LX63-safe rewrite)
-- Keeps: DevConsole toggle, Log Flooder (spam), Anti-Chatlogger, Notifications

local StartTime = tick()
if not game:IsLoaded() then
    game.Loaded:Wait()
end

local Players = game:GetService("Players")
local TextChatService = pcall(function() return game:GetService("TextChatService") end) and game:GetService("TextChatService") or nil
local CoreGui = game:GetService("CoreGui")
local StarterGui = game:GetService("StarterGui")
local UserInputService = game:GetService("UserInputService")
local lp = Players.LocalPlayer

local function ShowNotification(title, description)
    pcall(function()
        StarterGui:SetCore("SendNotification", {
            Title = title;
            Text = description;
            Icon = "rbxassetid://107909896307696";
            Duration = 10;
        })
    end)
end

if _G.VadriftsACLLoaded then
    pcall(function()
        if Rayfield and Rayfield.Notify then
            Rayfield:Notify({Title = "XCB AntiChatLogger", Content = "Anti Chatlogger has loaded", Image = 107909896307696, Duration = 5})
        end
    end)
    return
end
_G.VadriftsACLLoaded = true

print("Xyra's Anti Chatlogger Has Loaded")

-- safe helpers & feature detection ------------------------------------------------

local function safeCall(fn, ...)
    local ok, res = pcall(fn, ...)
    return ok, res
end

-- Detect if TextChannels API appears usable
local function hasTextChannels()
    if not TextChatService then return false end
    local ok, _ = pcall(function()
        return TextChatService.TextChannels
    end)
    return ok and (type(TextChatService.TextChannels) == "table" or typeof(TextChatService.TextChannels) == "Instance")
end

local TextChannelsAvailable = hasTextChannels()

-- If TextChannels is present but RBXGeneral isn't, attempt to use or create channels safely
local function safeAddChannel(name)
    if not TextChatService or not TextChannelsAvailable then return false end
    local ok, err = pcall(function()
        if TextChatService.AddChannel then
            TextChatService:AddChannel(name)
        else
            -- fallback: try indexing directly to avoid error
            local ch = TextChatService.TextChannels[name]
            if not ch then
                -- some executors won't allow creating channels; ignore
            end
        end
    end)
    return ok and true or false
end

-- Attempt to send message through several fallbacks.
-- Returns true on success, false otherwise.
local function safeSendToChat(channelName, message)
    -- 1) Preferred: TextChatService.TextChannels[channelName]:SendAsync(msg)
    if TextChatService and TextChannelsAvailable then
        local success, err = pcall(function()
            local chan = TextChatService.TextChannels and TextChatService.TextChannels[channelName]
            if chan and chan.SendAsync then
                chan:SendAsync(message)
                return true
            end
        end)
        if success then
            return true
        end
    end

    -- 2) Fallback: LocalPlayer:Chat (some executors provide this)
    if lp and lp.Chat then
        local ok = pcall(function() lp:Chat(message) end)
        if ok then return true end
    end

    -- 3) Fallback: TextChatService:SendSystemMessage (if available). Use pcall because not present everywhere.
    if TextChatService then
        local ok = pcall(function()
            if TextChatService.SendSystemMessage then
                -- second parameter (recipient) might be required per executor; we call with just message
                TextChatService:SendSystemMessage(message)
                return true
            end
        end)
        if ok then return true end
    end

    -- All attempts failed
    return false
end

-- Utility: safe get DevConsole references (wrapped in pcall)
local function getDevConsole()
    local ok, result = pcall(function()
        if CoreGui and CoreGui:FindFirstChild("DevConsoleMaster") then
            local d = CoreGui.DevConsoleMaster
            if d and d:FindFirstChild("DevConsoleWindow") then
                local w = d.DevConsoleWindow
                if w and w:FindFirstChild("DevConsoleUI") then
                    return d, w, w.DevConsoleUI
                end
            end
        end
        return nil
    end)
    if ok then return result end
    return nil
end

-- Console visibility state
local HiddingConsole = false
local LeavingConsoleOpen = false

-- Try to clone mainview safely (if present)
pcall(function()
    local d, w, ui = getDevConsole()
    if ui and ui:FindFirstChild("MainView") and not ui:FindFirstChild("MainView_Copy") then
        local ok, err = pcall(function()
            local NewMainView = ui.MainView:Clone()
            NewMainView.Visible = false
            NewMainView.Name = "MainView_Copy"
            NewMainView.Parent = ui
        end)
        if not ok then
            -- ignore if cloning is blocked on this executor
        end
    end
end)

-- Try to initially hide console after a short delay
task.spawn(function() task.wait(0.6)
    pcall(function()
        local d, w = getDevConsole()
        if w then w.Visible = false end
    end)
end)

-- Thread to keep console visibility in sync (safe pcall on each iteration)
task.spawn(function()
    while true do
        pcall(function()
            local d, w = getDevConsole()
            if w then
                if LeavingConsoleOpen then
                    w.Visible = true
                elseif HiddingConsole then
                    w.Visible = false
                end
            end
        end)
        task.wait(0.05)
    end
end)

-- Close button connection (safe)
pcall(function()
    local d, w, ui = getDevConsole()
    if ui and ui:FindFirstChild("TopBar") and ui.TopBar:FindFirstChild("CloseButton") then
        local CloseButton = ui.TopBar.CloseButton
        if CloseButton and CloseButton.MouseButton1Click then
            CloseButton.MouseButton1Click:Connect(function()
                LeavingConsoleOpen = false
                HiddingConsole = true
                pcall(function()
                    local d2, w2 = getDevConsole()
                    if w2 then w2.Visible = false end
                end)
            end)
        end
    end
end)

-- F9 toggle (local input)
UserInputService.InputBegan:Connect(function(input, gp)
    if not gp and input.KeyCode == Enum.KeyCode.F9 then
        if HiddingConsole or (not LeavingConsoleOpen and not HiddingConsole) then
            LeavingConsoleOpen = true
            HiddingConsole = false
        else
            LeavingConsoleOpen = false
            HiddingConsole = true
        end
    end
end)

-- Spam channel creation (safe)
for i = 1, 3 do
    pcall(function() safeAddChannel("SpamChannel"..i) end)
end

-- Generate a clean random token similar to original (avoids global 'string' override)
local function GenerateCleanString(length)
    local chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"
    local lesstagschanceig = {"fu", "shi", "tf", "ki", "bl"}
    local result = ""
    for i = 1, length do
        local idx = math.random(1, #chars)
        result = result .. string.sub(chars, idx, idx)
    end
    local low = result:lower()
    for _, w in pairs(lesstagschanceig) do
        low = string.gsub(low, w, "x")
    end
    -- preserve case somewhat by returning the original but filtered by `low`
    return low
end

local token = GenerateCleanString(8)
local floodMessage = "/console ".. token

-- Spam worker with adaptive throttling to avoid immediate crashes on fragile executors.
local spamDelay = 0.03 -- starting target (very fast)
local failureCount = 0
local failureBackoffThreshold = 10
local maxBackoffDelay = 0.3

task.spawn(function()
    while true do
        local ok = safeSendToChat("SpamChannel"..math.random(1,3), floodMessage)
        if not ok then
            failureCount = failureCount + 1
        else
            -- occasionally succeed -> lower failure count
            failureCount = math.max(0, failureCount - 1)
        end

        -- If we see repeated failures, increase wait time to avoid OOM/crash in LX63
        if failureCount >= failureBackoffThreshold then
            spamDelay = math.min(maxBackoffDelay, spamDelay + 0.05)
        else
            spamDelay = math.max(0.03, spamDelay - 0.01)
        end

        task.wait(spamDelay)
    end
end)

-- Single unified OnIncomingMessage handler
-- We will wrap any existing handler and call it safely; then perform our logic.
local oldIncoming = nil
local okGetOld, gotOld = pcall(function() return TextChatService and TextChatService.OnIncomingMessage end)
if okGetOld and gotOld then
    oldIncoming = gotOld
end

-- Flag to avoid prefixing same message multiple times
local function alreadyPrefixed(text)
    if type(text) ~= "string" then return false end
    -- the original prefix used a special char: "Ö¼" (U+05F0 like char)
    return text:sub(1, 1) == "Ö¼"
end

if TextChatService then
    -- Some executors have OnIncomingMessage as an event (Connect) instead of assignable property.
    -- Safest approach: if it's a function, overwrite; if it's an RBXScriptSignal, Connect to it.
    local success, isSignal = pcall(function()
        return typeof(TextChatService.OnIncomingMessage) == "RBXScriptSignal"
    end)

    if success and isSignal then
        -- Connect once
        TextChatService.OnIncomingMessage:Connect(function(message)
            pcall(function()
                -- call old handler if present (best-effort)
                if oldIncoming and type(oldIncoming) == "function" then
                    pcall(oldIncoming, message)
                end

                -- Toggle console on local user's "/console"
                if message.TextSource and message.TextSource.UserId == lp.UserId then
                    local text = tostring(message.Text):lower()
                    if text == "/console" or text:sub(1,9) == "/console " then
                        if HiddingConsole or (not LeavingConsoleOpen and not HiddingConsole) then
                            LeavingConsoleOpen = true
                            HiddingConsole = false
                        else
                            LeavingConsoleOpen = false
                            HiddingConsole = true
                        end
                    end
                end

                -- AntiChatLog: prefix if not already prefixed and not an emote (/e)
                local rawText = tostring(message.Text or "")
                if not alreadyPrefixed(rawText) and rawText:sub(1,2) ~= "/e" then
                    -- use pcall in case message.Text is protected
                    pcall(function() message.Text = "Ö¼" .. rawText end)
                end
            end)
        end)
    else
        -- OnIncomingMessage is assignable (older pattern). Replace carefully.
        local old = nil
        pcall(function() old = TextChatService.OnIncomingMessage end)
        TextChatService.OnIncomingMessage = function(message)
            -- call old handler safely
            if old and type(old) == "function" then
                pcall(old, message)
            end

            -- Toggle console for local player's message
            if message.TextSource and message.TextSource.UserId == lp.UserId then
                local text = tostring(message.Text):lower()
                if text == "/console" or text:sub(1,9) == "/console " then
                    if HiddingConsole or (not LeavingConsoleOpen and not HiddingConsole) then
                        LeavingConsoleOpen = true
                        HiddingConsole = false
                    else
                        LeavingConsoleOpen = false
                        HiddingConsole = true
                    end
                end
            end

            -- AntiChatLog: prefix messages unless emote (/e) or already prefixed
            local rawText = tostring(message.Text or "")
            if not alreadyPrefixed(rawText) and rawText:sub(1,2) ~= "/e" then
                pcall(function() message.Text = "Ö¼" .. rawText end)
            end
        end
    end
end

-- Final load time output & notification
local LoadTime = string.format("%.2f", tick() - StartTime)
print("Xyra's LogsFlooder & ResetFilter Loaded in ".. LoadTime .."s!")
pcall(function()
    if Rayfield and Rayfield.Notify then
        Rayfield:Notify({Title = "XCB AntiChatLogger", Content = "Log Flood & ResetFilter Loaded in ".. LoadTime .."s", Image = 107909896307696, Duration = 5})
    else
        ShowNotification("XCB AntiChatLogger", "Log Flood & ResetFilter Loaded in ".. LoadTime .."s")
    end
end)

-- Ensure chat visibility is enabled (safe loop)
task.spawn(function()
    repeat
        pcall(function() StarterGui:SetCoreGuiEnabled(Enum.CoreGuiType.Chat, true) end)
        task.wait()
    until pcall(function() return StarterGui:GetCoreGuiEnabled(Enum.CoreGuiType.Chat) end)
end)
